SECTION 1
Abstraction

SECTION 2
Lists
Lists are recursive data definitions. An example data definition for a list is as follows:

A List-of-names is one of :
- ‘()
- (cons String List-of-names)

When lists are formed, one must always start with an empty list. An empty list is denoted as ‘(). To check if a list is empty, we use the empty? predicate.

To form a list-of-names, we simply chain a list of cons statements as follows:
(define peer-mentors (cons “Rohit" (cons “Jeffrey” (cons “Hayden” (cons “Alin” (cons “Aaron” (cons “Nila” (cons “Prashanth” (cons “Shu” ‘()))

The above list is equivalent to:
(define peer-mentors (list “Rohit” “Jeffrey” “Hayden” “Alin” “Aaron” “Nila” “Shu” “Prashanth”))

Some other list functions that you may find useful include:
* append: [list of X] [list of X] [list of X]… -> [list of X]
            Constructs a new list from several lists by concatenating the argument lists together.
* remove: X [list of X] -> [list of X]
            Constructs a new list wth the first occurrence of X removed.
* length: [list of X] -> Number
            Returns the length of the argument list

SECTION 3
What is recursion?
Recursion occurs when a thing is defined in terms of itself or of its type.  

Consider the following data definition for a Train:

A trainCar is a (make-trainCar Number Train)
(define-struct TrainCar [capacity rest])

Consider the data definition for a Train:
A Train is one of:
* “caboose"
* (make-trainCar Number Train)

Here, the Train data-definition is defined in terms of a Train. Thus, the train data-definition is self-referential and said to be recursive.

How would we write a function to process this Train data-definition? Well, we should define a template that closely follows the recursive data-definition of the train.

The template would be as follows:
(define (process-train a-train)
    (cond
        [(string? a-train) …]
        [else … (train-capacity a-train) …
                 … process-train (train-rest a-train)…]
    )
)

If our train is a String, we know that the Train must be a “caboose”. If the train is a “caboose”, we know we’ve reached the end of the Train. This is because the Train definition of “caboose” does not refer to the Train data definition. When we’ve reached the caboose, we complete some computation and terminate our process-train function. 

If our train is not a String, it must be a trainCar. In this case, we complete some computation on the the current trainCar and then call process-train on the rest of the Train recursively, following the recursive data-definition of the Train.
 
Lists and 'list-like' data definitions (ex. the Train) are the most common recursive data-definitions that we’ve seen in class. Here is more information on lists. But, they certainly are not the only recursive data-definitions. Another example of a recursive data-definition that we've seen in class is the Alpaca. A generalization of the Alpaca
data-definition is a BinaryTree. Here is the data-definition for a BinaryTree:
* Binary Trees - Each Node is defined in terms of its left child Node and its right child Node. The formal data definition is:
  (define-struct Node [value left right])
  A BinaryTree is one of:
  - "leaf"
  -  (make-Node Number BinaryTree BinaryTree)

Some recursive data-definitions can get really complicated and difficult to work with. Remember though, with recusive data definitions, you can always use structural decomposition to write a template that follows the recursive structure of the data-definition to process the data.

  Exercise 1:
  Consider the following BinaryTree: 
  (make-Node 1 (make-Node 2 (make-Node 4 "leaf" "leaf")
                            (make-Node 5 "leaf" "leaf"))
                (make-Node 3 "leaf" "leaf"))
                
    Write a function to traverse the tree and add every element to the list in the following order:
    a. 4 2 5 1 3
    b. 1 2 4 5 3
    c. 4 5 2 3 1

SECTION 4
Mutual Recursion
Sometimes many data-definitions are defined in terms of each other. If this is the case, the data-definitions are said to be mutually recursive. To be more concrete, here is a simple example of some mutually recursive data definitions (for a more complicated example, see Lab 7 for the JSON data-definition):

(define-struct Tree [value children])
A Tree is one of:
- “leaf'
- (make-Tree Number Children)

Note: A tree must have at least one child.

Children is a [List of Tree]

Here, Tree refers to Children and Children refers to Tree. Tree and Children are said to be mutually recursive. How would we write a function to process this Tree and Children data-definitions? Again, we should define  templates that closely follows the recursive data-definitions of Tree and Children.

The templates would be as follows:
(define (process-tree (a-tree)
    (cond
        [(string? a-tree) …]
        [else … (Tree-value a-tree) ...
                … (process-children (Tree-children a-tree))
        ]
    )
)

(define (process-children (some-children)
    (cond
        [(empty? some-children) …]
        [else … (process-tree (first some-children)
                 …(process-children (rest some-children)
        ]
    )
)

When processing a Tree, we first check if the Tree is a leaf. If the Tree is a leaf, we complete some computation and end our recursion. If the Tree is not a leaf, we complete some computation on the Tree's value but then call our recursive process-children function on the Tree's children.

When processing a Tree's children, we first check if the list of children is empty. If our list is empty, we know we've already processed all of the children so we can end our recursion. If the list of children is not empty, we process the first Tree using our recursive process-Tree function,
and recursively call process-children on the rest of the tree's children.

Exercise 2:
Write a template to process the following mutually recursive data definitions:
A ListOfAlternatingNumbersandStrings is one of:
- '()
- (cons Number ListOfAlternatingStringsandNumbers)

A ListOfAlternatingStringsandNumbers is one of:
- '()
- (cons Number ListOfAlternatingNumbersandStrings)

Note: Example taken from Mitchell Wand's Northeastern University Lecture on Mutually-Recursive Data Definitions

SECTION 5
Generative Recursion
The recursion examples in Sections 3 and 4 are examples of structural recursion - that is, we exploit the structure of our data definition to organize
the structure of our code. More concretely, if we are writing a function to do some computation on a list, we know we must process the first element of the list
and then the rest of the list. While structural recursion is a useful tool that can be used to solve some problems with recursive solutions, it cannot be used to s
olve all problems. Namely, it cannot solve problems where the input is not defined recursively. 

Generative recursion a general problem-solving technique that can be applied to a wide class of problems. Generative recursion generates a set of subproblems
from the current problem at hand. The answers to these subproblems are then combined to provide the solution.

Here is the template for general recursion:
(define (generative-recursive-fun problem)
  (cond
    [(trivially-solvable? problem)
     (determine-solution problem)]
    [else
     (combine-solutions
       ... problem ...
       (generative-recursive-fun (generate-problem-1 problem))
       ...
       (generative-recursive-fun (generate-problem-n problem)))]))

See lecture 17 for some great worked examples of generative recursion (mergesort, quicksort, fibonacci). Here is an additional worked example of generative recursion:

Background: The Euclidean algorithm is an efficient way to find the greatest common divisor of two positive integers A and B. The algorithm works by repeated division. 
Read https://en.wikipedia.org/wiki/Euclidean_algorithm to understand the mechanics of the algorithm.

Now let's write a ISL function to calculate the GCD of two numbers.
; GCD : Natural Natural -> Natural
(define (GCD A B)
    (cond 
        [(zero? B) A]
        [else (GCD B (modulo A B))]
     )
)

Why does this program terminate? It isn't immediately obvious.

Run this function on a few different A and B inputs and use the DrRacket stepper. You will see that at each iteration of the algorithm,
the modulo decreases by at least 1. Eventually, the modulo value reaches 0 and the program reaches its termination condition. 

Notice how each recusive call to GCD is generated based on the euclidean algorithm, and not the structure of the input (a natural number).
Generative recursion problems are usually more challenging to solve than structural recursion problems and usually require some domain specific knowledge.

SECTION 6
Map, Filter, Foldr
Map, filter, and foldr are examples of 'higher-order' functions. A higher-order function is a function that either:
- takes another function as an input
- returns a function
Map, filter, and foldr each take functions as inputs.

Here are the semantics of map, filter, and foldr. See 
* Map: [F: X ->Y] [List of X] -> [List of Y] - Map applies a function to each element of a list and returns the list 
  of results in the same order as the original list.
  Ex. 
  ; Multiply by 2
  (map (lambda (x) (* x 2)) (list 1 2 3 4 5)) -> (list 2 4 6 8 10)

* Filter: [F: X->Boolean] [List of X] -> [List of X] - Filter applies a function to each element of a list and returns the list
  of elements that the function returns true for.
  Ex.
  ; Filter even numbers
  (filter (lambda (x) (= 0 (modulo x 2))) (list 1 2 3 4 5) -> (list 2 4)

* Andmap: [F: X->Boolean] [List of X] -> Boolean - Andmap applies a function to each element of a list and 'and's each result together
  Ex.
  ; Are all elements even?
  (andmap (lambda(x) (= 0 (modulo x 2))) (list 2 4 6 8)) -> #true

* Ormap: [F: X->Boolean] [List of X] -> Boolean - Ormap applies a function to each element of a list and 'or's each result together
  Ex.
  ; Is there at least one even element in the list?
  (ormap (lambda(x) (= 0 (modulo x 2))) (list 1 3 5 7 2)) -> #true

* Foldr: [F: X Y -> Y] Y [List of X] -> Y - Foldr applies a function to each element of a list (starting with the right) and the second argument
  of foldr. It subsequently updates the second argument with this return value. Once all elements of the input list have been considered, the second argument 
  is returned.
  Ex.
  ; Sum all elements in a list
  (foldr (lambda (x y) (+ x y) 0 (list 1 2 3 4 5))) -> 15

  Exercise 3: Use foldr to write map 
  Exercise 4 Use foldr to write andmap and ormap
  Exercise 5: Use foldr to write filter (hint: use andmap)
  Exercise 6: When might it be useful to use map with a higher order-function that returns a function and a list to return a list of functions?


SECTION 7
Local and Lambda
Lambda
The keyword lambda defines 'anonymous' functions. An anonymous function is simply a function not bound to a name. Lambda functions are generally used to define
functions that higher-order functions take as input. See the section on Map, Filter, and Foldr for some examples. Lambda functions are generally preferred to 
named functions in the context of higher order functions as the function definition code is kept close to its call within the higher order function. Also, lambda
functions are generally used for one-off computations exclusively used in the context of the higher-order-function is defined, so it doesn't make sense for the functions
to be defined globally in the program.

Local
Use cases:
- names for intermediate values, helps break complicated expressesions into a series of simpler ones
- limit the scope of helper functions 


Closures
