SECTION 1
Abstraction

SECTION 2
Lists
Lists are recursive data definitions. An example data definition for a list is as follows:

A List-of-names is one of :
- ‘()
- (cons String List-of-names)

When lists are formed, one must always start with an empty list. An empty list is donated as ‘(). To check if a list is empty, we use the empty? predicate.

To form a list-of-names, we simply chain a list of cons statements as follows:
(define peer-mentors (cons “Rohit" (cons “Jeffrey” (cons “Hayden” (cons “Alin” (cons “Aaron” (cons “Nila” (cons “Prashanth” (cons “Shu” ‘()))

The above list is equivalent to:
(define peer-mentors (list “Rohit” “Jeffrey” “Hayden” “Alin” “Aaron” “Nila” “Shu” “Prashanth”))

Some other list functions that you may find useful include:
* append: [list of X] [list of X] [list of X]… -> [list of X]
            Constructs a new list from several lists by concatenating the argument lists together.
* remove: X [list of X] -> [list of X]
            Constructs a new list wth the first occurrence of X removed.
* length: [list of X] -> Number
            Returns the length of the argument list

SECTION 3
What is recursion?
Recursion occurs when a thing is defined in terms of itself or of its type.  

Consider the following data definition for a Train:

A trainCar is a (make-trainCar Number Train)
(define-struct TrainCar [capacity rest])

Consider the data definition for a Train:
A Train is one of:
* “caboose"
* (make-trainCar Number Train)

Here, the Train data-definition is defined in terms of a Train. Thus, the train data-definition is self-referential and said to be recursive.

How would we write a function to process this Train data-definition? Well, we should define a template that closely follows the recursive data-definition of the train.

The template would be as follows:
(define (process-train a-train)
    (cond
        [(string? a-train) …]
        [else … (train-capacity a-train) …
                 … process-train (train-rest a-train)…]
    )
)

If our train is a String, we know that the Train must be a “caboose”. If the train is a “caboose”, we know we’ve reached the end of the Train. This is because the Train definition of “caboose” does not refer to the Train data definition. When we’ve reached the caboose, we complete some computation and terminate our process-train function. 

If our train is not a String, it must be a trainCar. In this case, we complete some computation on the the current trainCar and then call process-train on the rest of the Train recursively, following the recursive data-definition of the Train.
 
Lists and 'list-like' data definitions (ex. the Train) are the most common recursive data-definitions that we’ve seen in class. Here is more information on lists. But, they certainly are not the only recursive data-definitions. Other examples of recursive data-definitions include:
* Binary Tree Nodes - Each Node is defined in terms of its left child Node and its right child Node. 
* Alpacas - Each Alpaca is defined in terms of its sire Alpaca and dam Alpaca
Some recursive data-definitions can get really crazy and hard to wrap your head around. But for every recursive-data definition, you can use structural decomposition and write a template that follows the recursive structure of the data-definition to process the data.

SECTION 4
Mutual Recursion
Sometimes two data-defintitions are defined in terms of each other. If this is the case, the data-definitions are said to be mutually recursive. To be more concrete, here is a simple example of some mutually recursive data definitions (for a more complicated example, see Lab 7 for the JSON data-definition):

(define-struct Tree [value children])
A Tree is one of:
- “leaf'
- (make-Tree Number Children)

Children is a [List of Tree]

Here, Tree refers to Children and Children refers to Tree. Tree and Children are said to be mutually recursive. How would we write a function to process this Tree and Children data-definitions? Again, we should define  templates that closely follows the recursive data-definitions of Tree and Children.

The templates would be as follows:
(define (process-tree (a-tree)
    (cond
        [(string? a-tree) …]
        [else … (Tree-value a-tree) ...
                … (process-children (Tree-children a-tree))
        ]
    )
)

(define (process-children (some-children)
    (cond
        [ (empty? some-children) …]
        [else … (process-tree (first some-children)
                 …(process-children (rest some-children)
        ]
    )
)

SECTION 5
Generative Recursion

SECTION 6
Map, Filter, Foldr

SECTION 7
Local and Lambda
