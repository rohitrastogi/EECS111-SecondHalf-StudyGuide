SECTION 1
Abstraction

SECTION 2
Lists
Lists are recursive data definitions. An example data definition for a list is as follows:

A List-of-names is one of :
- ‘()
- (cons String List-of-names)

When lists are formed, one must always start with an empty list. An empty list is denoted as ‘(). To check if a list is empty, we use the empty? predicate.

To form a list-of-names, we simply chain a list of cons statements as follows:
(define peer-mentors (cons “Rohit" (cons “Jeffrey” (cons “Hayden” (cons “Alin” (cons “Aaron” (cons “Nila” (cons “Prashanth” (cons “Shu” ‘()))

The above list is equivalent to:
(define peer-mentors (list “Rohit” “Jeffrey” “Hayden” “Alin” “Aaron” “Nila” “Shu” “Prashanth”))

Some other list functions that you may find useful include:
* append: [list of X] [list of X] [list of X]… -> [list of X]
            Constructs a new list from several lists by concatenating the argument lists together.
* remove: X [list of X] -> [list of X]
            Constructs a new list wth the first occurrence of X removed.
* length: [list of X] -> Number
            Returns the length of the argument list

SECTION 3
What is recursion?
Recursion occurs when a thing is defined in terms of itself or of its type.  

Consider the following data definition for a Train:

A trainCar is a (make-trainCar Number Train)
(define-struct TrainCar [capacity rest])

Consider the data definition for a Train:
A Train is one of:
* “caboose"
* (make-trainCar Number Train)

Here, the Train data-definition is defined in terms of a Train. Thus, the train data-definition is self-referential and said to be recursive.

How would we write a function to process this Train data-definition? Well, we should define a template that closely follows the recursive data-definition of the train.

The template would be as follows:
(define (process-train a-train)
    (cond
        [(string? a-train) …]
        [else … (train-capacity a-train) …
                 … process-train (train-rest a-train)…]
    )
)

If our train is a String, we know that the Train must be a “caboose”. If the train is a “caboose”, we know we’ve reached the end of the Train. This is because the Train definition of “caboose” does not refer to the Train data definition. When we’ve reached the caboose, we complete some computation and terminate our process-train function. 

If our train is not a String, it must be a trainCar. In this case, we complete some computation on the the current trainCar and then call process-train on the rest of the Train recursively, following the recursive data-definition of the Train.
 
Lists and 'list-like' data definitions (ex. the Train) are the most common recursive data-definitions that we’ve seen in class. Here is more information on lists. But, they certainly are not the only recursive data-definitions. Other examples of recursive data-definitions include:
* Binary Tree Nodes - Each Node is defined in terms of its left child Node and its right child Node. 
* Alpacas - Each Alpaca is defined in terms of its sire Alpaca and dam Alpaca
Some recursive data-definitions can get really crazy and hard to wrap your head around. But for every recursive-data definition, you can use structural decomposition and write a template that follows the recursive structure of the data-definition to process the data.

SECTION 4
Mutual Recursion
Sometimes two data-defintitions are defined in terms of each other. If this is the case, the data-definitions are said to be mutually recursive. To be more concrete, here is a simple example of some mutually recursive data definitions (for a more complicated example, see Lab 7 for the JSON data-definition):

(define-struct Tree [value children])
A Tree is one of:
- “leaf'
- (make-Tree Number Children)

Children is a [List of Tree]

Here, Tree refers to Children and Children refers to Tree. Tree and Children are said to be mutually recursive. How would we write a function to process this Tree and Children data-definitions? Again, we should define  templates that closely follows the recursive data-definitions of Tree and Children.

The templates would be as follows:
(define (process-tree (a-tree)
    (cond
        [(string? a-tree) …]
        [else … (Tree-value a-tree) ...
                … (process-children (Tree-children a-tree))
        ]
    )
)

(define (process-children (some-children)
    (cond
        [ (empty? some-children) …]
        [else … (process-tree (first some-children)
                 …(process-children (rest some-children)
        ]
    )
)

SECTION 5
Generative Recursion

SECTION 6
Map, Filter, Foldr
Map, filter, and foldr are examples of 'higher-order' functions. A higher-order function is a function that either:
- takes another function as an input
- returns a function
Map, filter, and foldr each take functions as inputs.

Here are the semantics of map, filter, and foldr. See 
* Map: [F: X ->Y] [List of X] -> [List of Y] - Map applies a function to each element of a list and returns the list 
  of results in the same order as the original list.
  Ex. 
  ; Multiply by 2
  (map (lambda (x) (* x 2)) (list 1 2 3 4 5)) -> (list 2 4 6 8 10)

* Filter: [F: X->Boolean] [List of X] -> [List of X] - Filter applies a function to each element of a list and returns the list
  of elements that the function returns true for.
  Ex.
  ; Filter even numbers
  (filter (lambda (x) (= 0 (modulo x 2))) (list 1 2 3 4 5) -> (list 2 4)

* Andmap: [F: X->Boolean] [List of X] -> Boolean - Andmap applies a function to each element of a list and 'and's each result together
  Ex.
  ; Are all elements even?
  (andmap (lambda(x) (= 0 (modulo x 2))) (list 2 4 6 8)) -> #true

* Ormap: [F: X->Boolean] [List of X] -> Boolean - Ormap applies a function to each element of a list and 'or's each result together
  Ex.
  ; Is there at least one even element in the list?
  (ormap (lambda(x) (= 0 (modulo x 2))) (list 1 3 5 7 2)) -> #true

* Foldr: [F: X Y -> Y] Y [List of X] -> Y - Foldr applies a function to each element of a list (starting with the right) and the second argument
  of foldr. It subsequently updates the second argument with this return value. Once all elements of the input list have been considered, the second argument 
  is returned.
  Ex.
  ; Sum all elements in a list
  (foldr (lambda (x y) (+ x y) 0 (list 1 2 3 4 5))) -> 15

  Exercise 1: Use foldr to write map 
  Exercise 2 Use foldr to write andmap and ormap
  Exercise 3: Use foldr to write filter (hint: use andmap)
  Exercise 4: When might it be useful to use map with a higher order-function that returns a function and a list to return a list of functions?


SECTION 7
Local and Lambda
Lambda
The keyword lambda defines 'anonymous' functions. An anonymous function is simply a function not bound to a name. Lambda functions are generally used to define
functions that higher-order functions take as input. See the section on Map, Filter, and Foldr for some examples. Lambda functions are generally preferred to 
named functions in the context of higher order functions as the function definition code is kept close to its call within the higher order function. Also, lambda
functions are generally used for one-off computations exclusively used in the context of the higher-order-function is defined, so it doesn't make sense for the functions
to be defined globally in the program.

Local
Use cases:
- names for intermediate values, helps break complicated expressesions into a series of simpler ones
- limit the scope of helper functions 


Closures
